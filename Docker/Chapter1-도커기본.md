---

# 도커를 쓰는 이유

### 도커 없이 프로그램 받을 때 원래 프로그램을 다운받고 실행하는 순서

Installer 다운 → Installer 실행 → 프로그램 설치완료

But…

Installer 다운 → Installer 실행 → `에러...`

> 갖고 있는 서버, 패키지 버전, 운영체제 등에 따라 프로그램을 설치하는 과정중에 많은 에러들이 발생하게 됨

# 도커는 무엇인가요 ?

`컨테이너` 를 사용하여 응용프로그램을 더 쉽게 만들고 배포하고 실행할 수 있도록 설계된 도구이며, `컨테이너` 기반의 오픈소스 가상화 플랫폼이며 생태계입니다.

# 그러면 컨테이너는 무엇인가요 ?

https://www.docker.com/resources/what-container/

일반적인 컨테이너의 개념

- 컨테이너 안에 물건을 넣고 다양한 운송 수단으로 쉽게 옮길 수 있음

서버에서의 컨테이너의 개념

- 다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램의 배포 및 관리를 단순하게 해줌
- 일반 컨테이너의 개념에서 물건을 손쉽게 운송해주는 것 처럼, 프로그램을 손쉽게 이동, 배포, 관리를 할 수 있게 해줌
- AWS, Azure, Google cloud등 어디에서든 실행 가능하게 해줌

# 도커 이미지와 컨테이너 정의 간단히 살펴보기

`컨테이너` 는 코드와 모든 종속성을 패키지화 하여 응용 프로그램이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 하는 소프트웨어의 표준 단위이다.

컨테이너`이미지` 는 코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용 프로그램을 실행하는데 필요한 모든 것을 포함하는 가볍고 독립적이며 실행 가능한 소프트웨어 패키지 입니다.

또한 컨테이너`이미지` 는 런타임에 컨테이너가 되고 도커 컨테이너의 경우 도커 엔진에서 실행될 때 이미지가 컨테이너가 됩니다.

리눅스와 윈도우 기반 애플리케이션 모두에서 사용할 수 있는 컨테이너화된 소프트웨어는 인프라에 관계없이 항상 동일하게 실행됩니다.

컨테이너는 소프트웨어를 환경으로부터 격리시키고 개발과 스테이징의 차이에도 불구하고 균일하게 작동하도록 보장합니다.

![image.png](attachment:e27374a5-1108-4d3b-963e-35d954d6cdbf:image.png)

여기서는 간단하게

도커 이미지는 프로그램을 실행하는데 필요한 설정이나 종속성을 갖고 있으며,
도커 이미지를 이용해서 컨테이너를 실행하며,
도커 컨테이너를 이용하여 프로그램을 실행한다. 정도로 기억하기

# 항상 도커를 사용할 때는…

1. 먼저 도커 Client(CLI)에 커맨드를 입력한다.
2. 그러면 도커 서버 (도커 Daemon)이 그 커맨드를 받아서 그것에 따라 이미지를 생성하든 컨테이너를 실행하든 모든 작업을 하게 된다.

- 도커 Client(CLI) → 도커 Server(Daemon)

# 실제로 CLI에서 커맨드를 입력해보기

1. docker run hello-world
2. 도커 클라이언트
3. 도커 서버
4. 이미지 Cache 보관 장소(hello-world)이미지가 있나요?
   1. 만약 캐시 보관장소에 이미지가 없다면 도커 허브에서 가져오기
5. 도커 허브(이미지들을 보관)

## 이제 hello-world 이미지가 캐쉬가 되어있으니 한번 더 docker run hello-world하면 어떻게 될까?

1. Unalbe to find image ~ 라는 문구가 없이 프로그램이 실행됨.
2. 결국은 캐쉬된 이미지를 이용해서 컨테이너를 만든 후 프로그램을 실행.

# 도커와 기존의 가상화 기술과의 차이를 통한 컨테이너 이해

가상화 기술 나오기 전

- 한대의 서버를 하나의 용도로만 사용
- 남는 서버 공간 그대로 방치
- 하나의 서버에 하나의 운영체제, 하나의 프로그램만을 운영
- 안정적 But 비효율적

하이퍼 바이저 기반의 가상화 출현

- 논리적으로 공간을 분할하여 VM이라는 독립적인 가상 환경의 서버 이용가능
- 하이퍼 바이저는 다수의 게스트 OS를 구동할 수 있게 하는 소프트웨어
- 그리고 하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링 하는 중간 관리자이다.

### 하이퍼 바이저

`네이티브 하이퍼 바이저`

- 하드웨어 → 하이퍼 바이저 → OS
- 하이퍼 바이저가 하드웨어를 직접 제어하기에 자원을 효율적으로 사용가능
- 별도의 호스트 OS가 없으므로 오버헤드가 적다.
- 하지만 여러 하드웨어 드라이버를 세팅해야 하므로 설치가 어렵다.

`호스트형 하이퍼 바이저`

- 하드웨어 → OS → 하이퍼 바이저 → OS
- 일반적인 소프트웨어처럼 호스트 OS 위에서 실행되며, 하드웨어 자원을 VM 내부에 게스트 OS에 에뮬레이트 하는 방식으로 오버헤드가 크다.
- 하지만 게스트 OS 종류에 대한 제약이 없고 구현이 다소 쉽다.
- 일반적으로 많이 사용하는 방법

![image.png](attachment:a45c1c91-bf69-49cc-a79d-3c124f1a2190:image.png)

하이퍼바이저에 의해 구동되는 VM은 각 VM마다 독립된 가상 하드웨어 자원을 할당 받음.

논리적으로 분리되어 있어서 한 VM에 오류가 발생해도 다른 VM으로 퍼지지 않는다는 장점이 있음.

# 도커와 기존 가상화 기술 구조

![image.png](attachment:b23ca68f-c6d0-4e5a-b8ea-9dd7fd3ecd2c:image.png)

![image.png](attachment:7614a269-eff2-4d52-b52d-cbcb6751c878:image.png)

### 공통점

도커 컨테이너와 가상 머신은 기본 하드웨어에서 격리된 환경 내에 애플리케이션을 배치하는 방법

### 차이점

가장 큰 차이점은 격리된 환경을 얼마나 격리 시키는지의 차이

# 컨테이너들을 격리시키는데, 어떻게 해서 도커 컨테이너를 격리 시킬까요?

> 먼저 리눅스에서 쓰이는 `Cgroup`(Control Groups)과 `네임스페이스`(namespaces)에 대해서 알아야 한다.
> 이것들은 컨테이너와 호스트에서 실행되는 다른 프로세스 사이에 벽을 만든느 리눅스 커널 기능들입니다.

**C Group**

- CPU, 메모리, Network Bandwith, HD i/o 등 프로세스 그룹의 시스템 리소스 사용량을 관리

→ 어떤 어플이 사용량이 너무 많다면 그 어플리케이션 같은 것을 C Group에 집어 넣어서 CPU와 메모리 사용 제한 가능

**네임스페이스**

- 하나의 시스템에서 프로세스를 격리시킬 수 있는 가상화 기술
- 별개의 독립된 공간을 사용하는 것처럼 격리된 환경을 제공하는 경량 프로세스 가상화 기술

![image.png](attachment:30b2dff0-0cc1-49b0-adf1-7633253e380c:image.png)

# 이미지로 컨테이너를 만들기

> 이미지는 응용 프로그램을 실행하는데 `필요한 모든 것` 을 포함하고 있습니다.

**필요한 것이란?**

- 컨테이너가 시작 될 때 실행되는 명령어
  - ex) run kakaotalk
- 파일 스냅샷
  - ex) 컨테이너에서 카카오톡을 실행하고 싶다면 카카오톡 파일(카카오톡을 실행하는데 필요한 파일) 스냅샷
  - 파일 스냅샷은 디렉토리나 파일을 카피한 것

![image.png](attachment:be5c0068-8c88-4f1d-bfc5-39b9819f2951:image.png)

# 이미지로 컨테이너 만드는 순서

1. Docker 클라이언트에 docker run <이미지> 입력
2. 도커 이미지에 있는 파일 스냅샷을 컨테이너 하드 디스크에 옮겨 주기

# Cgroup, 네임스페이스를 도커환경에서 쓸 수 있는 이유

컨테이너를 격리 시킬 수 있는 이유는 Cgroup과 네임스페이스를 이용해서이다…

하지만 생각해보면 Cgroup과 네임스페이스는 리눅스 환경에서 사용 되어지는 것인데…

![image.png](attachment:0725a130-9350-47d5-ba0d-7b63fee64ea1:image.png)

![image.png](attachment:ae970281-e950-43d0-a5c3-10f401921b86:image.png)
